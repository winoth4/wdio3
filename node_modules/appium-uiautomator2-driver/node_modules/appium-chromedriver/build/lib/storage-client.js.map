{"version":3,"file":"storage-client.js","names":["TIMEOUT_MS","MAX_PARALLEL_DOWNLOADS","log","logger","getLogger","isCrcOk","src","checksum","md5","fs","hash","_","toLower","findChildNode","parent","childName","text","hasChildNodes","childNodeIdx","childNodes","length","childNode","localName","childText","extractNodeText","node","firstChild","util","hasValue","nodeValue","ChromedriverStorageClient","constructor","args","chromedriverDir","getChromedriverDir","timeout","mapping","parseNotes","content","result","versionMatch","exec","version","minBrowserVersionMatch","minBrowserVersion","retrieveAdditionalDriverInfo","driverKey","notesUrl","infoDict","notes","retrieveData","accept","debug","parseStorageXml","doc","shouldParseNotes","driverNodes","xpath","select","isEmpty","promises","driverNode","key","includes","etag","cdInfo","url","CD_CDN","trim","first","split","notesPath","isNotesPresent","reduce","acc","info","push","B","all","size","retrieveMapping","xml","DOMParser","parseFromString","cloneDeep","unzipDriver","dst","tmpRoot","tempDir","openDir","zip","extractAllTo","chromedriverPath","walkDir","itemPath","isDirectory","path","parse","name","Error","basename","mv","mkdirp","rimraf","selectMatchingDrivers","osInfo","opts","versions","driversToSync","keys","filter","cdName","pluralize","isNaN","minBrowserVersionInt","parseInt","closestMatchedVersionNumber","currentMinBrowserVersion","uniq","map","arch","hardwareName","X64","some","X86","OS","mac","M1_ARCH_SUFFIX","platformRe","RegExp","test","retrieveDriver","index","archivesRoot","isStrict","archivePath","resolve","net","downloadFile","isMetered","e","msg","message","error","fileName","system","isWindows","targetPath","chmod","syncDrivers","getOsInfo","JSON","stringify","synchronizedDrivers","idx","entries"],"sources":["../../lib/storage-client.js"],"sourcesContent":["import {\n  getChromedriverDir, CD_CDN, retrieveData, getOsInfo,\n  OS, X64, X86, M1_ARCH_SUFFIX,\n} from './utils';\nimport _ from 'lodash';\nimport xpath from 'xpath';\nimport { DOMParser } from '@xmldom/xmldom';\nimport B from 'bluebird';\nimport path from 'path';\nimport { system, fs, logger, tempDir, zip, util, net } from '@appium/support';\n\n\nconst TIMEOUT_MS = 15000;\nconst MAX_PARALLEL_DOWNLOADS = 5;\n\nconst log = logger.getLogger('ChromedriverStorageClient');\n\n\nasync function isCrcOk (src, checksum) {\n  const md5 = await fs.hash(src, 'md5');\n  return _.toLower(md5) === _.toLower(checksum);\n}\n\nfunction findChildNode (parent, childName = null, text = null) {\n  if (!childName && !text) {\n    return null;\n  }\n  if (!parent.hasChildNodes()) {\n    return null;\n  }\n\n  for (let childNodeIdx = 0; childNodeIdx < parent.childNodes.length; childNodeIdx++) {\n    const childNode = parent.childNodes[childNodeIdx];\n    if (childName && !text && childName === childNode.localName) {\n      return childNode;\n    }\n    if (text) {\n      const childText = extractNodeText(childNode);\n      if (!childText) {\n        continue;\n      }\n      if (childName && childName === childNode.localName && text === childText) {\n        return childNode;\n      }\n      if (!childName && text === childText) {\n        return childNode;\n      }\n    }\n  }\n  return null;\n}\n\nfunction extractNodeText (node) {\n  return (!node || !node.firstChild || !util.hasValue(node.firstChild.nodeValue))\n    ? null\n    : node.firstChild.nodeValue;\n}\n\n\nclass ChromedriverStorageClient {\n  constructor (args = {}) {\n    const {\n      chromedriverDir = getChromedriverDir(),\n      timeout = TIMEOUT_MS,\n    } = args;\n    this.chromedriverDir = chromedriverDir;\n    this.timeout = timeout;\n    this.mapping = {};\n  }\n\n  /**\n   * @typedef {Object} AdditionalDriverDetails\n   * @property {?string} version - Chromedriver version\n   * or `null` if it cannot be found\n   * @property {?string} minBrowserVersion - The minimum browser version\n   * supported by chromedriver or `null` if it cannot be found\n   */\n\n  /**\n   * Gets additional chromedriver details from chromedriver\n   * release notes\n   *\n   * @param {string} content - Release notes of the corresponding chromedriver\n   * @returns {AdditionalDriverDetails}\n   */\n  parseNotes (content) {\n    const result = {};\n    const versionMatch = /^\\s*[-]+ChromeDriver[\\D]+([\\d.]+)/im.exec(content);\n    if (versionMatch) {\n      result.version = versionMatch[1];\n    }\n    const minBrowserVersionMatch = /^\\s*Supports Chrome[\\D]+(\\d+)/im.exec(content);\n    if (minBrowserVersionMatch) {\n      result.minBrowserVersion = minBrowserVersionMatch[1];\n    }\n    return result;\n  }\n\n  /**\n   * Downloads chromedriver release notes and puts them\n   * into the dictionary argument\n   *\n   * @param {string} driverKey - Driver version plus archive name\n   * @param {string} notesUrl - The URL of chromedriver notes\n   * @param {Object} infoDict - The dictionary containing driver info.\n   * The method call mutates by merging `AdditionalDriverDetails`\n   * @throws {Error} if the release notes cannot be downloaded\n   */\n  async retrieveAdditionalDriverInfo (driverKey, notesUrl, infoDict) {\n    const notes = await retrieveData(notesUrl, {\n      'user-agent': 'appium',\n      accept: '*/*',\n    }, { timeout: this.timeout });\n    const { minBrowserVersion } = this.parseNotes(notes);\n    if (!minBrowserVersion) {\n      log.debug(`The driver '${driverKey}' does not contain valid release notes at ${notesUrl}. ` +\n        `Skipping it`);\n      return;\n    }\n    infoDict.minBrowserVersion = minBrowserVersion;\n  }\n\n  /**\n   * Parses chromedriver storage XML and stores\n   * the parsed results into `this.mapping`\n   *\n   * @param {DOMDocument} doc - The DOM representation\n   * of the chromedriver storage XML\n   * @param {boolean} shouldParseNotes [true] - If set to `true`\n   * then additional drivers information is going to be parsed\n   * and assigned to `this.mapping`\n   */\n  async parseStorageXml (doc, shouldParseNotes = true) {\n    const driverNodes = xpath.select(`//*[local-name(.)='Contents']`, doc);\n    log.debug(`Parsed ${driverNodes.length} entries from storage XML`);\n    if (_.isEmpty(driverNodes)) {\n      return;\n    }\n\n    const promises = [];\n    for (const driverNode of driverNodes) {\n      const key = extractNodeText(findChildNode(driverNode, 'Key'));\n      if (!_.includes(key, '/chromedriver_')) {\n        continue;\n      }\n\n      const etag = extractNodeText(findChildNode(driverNode, 'ETag'));\n      if (!etag) {\n        log.debug(`The entry '${key}' does not contain the checksum. Skipping it`);\n        continue;\n      }\n\n      const cdInfo = {\n        url: `${CD_CDN}/${key}`,\n        etag: _.trim(etag, '\"'),\n        version: _.first(key.split('/')),\n      };\n      this.mapping[key] = cdInfo;\n\n      const notesPath = `${cdInfo.version}/notes.txt`;\n      const isNotesPresent = !!driverNodes\n        .reduce((acc, node) => acc || findChildNode(node, 'Key', notesPath), false);\n      if (!isNotesPresent) {\n        cdInfo.minBrowserVersion = null;\n        if (shouldParseNotes) {\n          log.info(`The entry '${key}' does not contain any notes. Skipping it`);\n        }\n        continue;\n      } else if (!shouldParseNotes) {\n        continue;\n      }\n\n      promises.push(this.retrieveAdditionalDriverInfo(key, `${CD_CDN}/${notesPath}`, cdInfo));\n      if (promises.length % MAX_PARALLEL_DOWNLOADS === 0) {\n        await B.all(promises);\n      }\n    }\n    await B.all(promises);\n    log.info(`The total count of entries in the mapping: ${_.size(this.mapping)}`);\n  }\n\n  /**\n   * @typedef {Object} DriverDetails\n   * @property {string} url - The full url to the corresponding driver in\n   * the remote storage\n   * @property {string} etag - The CRC of the driver archive\n   * @property {string} version - Chromedriver version\n   */\n\n  /**\n   * @typedef {Object} ChromedriversMapping\n   * @property {DriverDetails} - The keys are unique driver identifiers\n   * (version/archive name). The corresponding values have `DriverDetails`\n   * containing chromedriver details\n   */\n\n  /**\n   * Retrieves chromedriver mapping from the storage\n   *\n   * @param {boolean} shouldParseNotes [true] - if set to `true`\n   * then additional chromedrivers info is going to be retrieved and\n   * parsed from release notes\n   * @returns {ChromedriversMapping}\n   */\n  async retrieveMapping (shouldParseNotes = true) {\n    const xml = await retrieveData(CD_CDN, {\n      'user-agent': 'appium',\n      accept: 'application/xml, */*',\n    }, { timeout: this.timeout });\n    const doc = new DOMParser().parseFromString(xml);\n    await this.parseStorageXml(doc, shouldParseNotes);\n    return _.cloneDeep(this.mapping);\n  }\n\n  /**\n   * Extracts downloaded chromedriver archive\n   * into the given destination\n   *\n   * @param {string} src - The source archive path\n   * @param {string} dst - The destination chromedriver path\n   */\n  async unzipDriver (src, dst) {\n    const tmpRoot = await tempDir.openDir();\n    try {\n      await zip.extractAllTo(src, tmpRoot);\n      const chromedriverPath = await fs.walkDir(tmpRoot, true, (itemPath, isDirectory) =>\n        !isDirectory && _.toLower(path.parse(itemPath).name) === 'chromedriver');\n      if (!chromedriverPath) {\n        throw new Error('The archive was unzipped properly, but we could not find any chromedriver executable');\n      }\n      log.debug(`Moving the extracted '${path.basename(chromedriverPath)}' to '${dst}'`);\n      await fs.mv(chromedriverPath, dst, {\n        mkdirp: true\n      });\n    } finally {\n      await fs.rimraf(tmpRoot);\n    }\n  }\n\n  /**\n   * @typedef {Object} OSInfo\n   * @property {string} name - The name of the host OS\n   * Can be either `mac`, `windows` or `linux`\n   * @property {string} arch - The architecture of the host OD.\n   * Can be either `32` or `64`\n   * @property {?string} hardwareName - The output of `uname -m` command\n   * on linux and mac systems. `null` on Windows\n   */\n\n  /**\n   * Filters `this.mapping` to only select matching\n   * chromedriver entries by operating system information\n   * and/or additional synchronization options (if provided)\n   *\n   * @param {?OSInfo} osInfo\n   * @param {?SyncOptions} opts\n   * @returns {Array<String>} The list of filtered chromedriver\n   * entry names (version/archive name)\n   */\n  selectMatchingDrivers (osInfo, opts = {}) {\n    const {\n      minBrowserVersion,\n      versions = [],\n    } = opts;\n    let driversToSync = _.keys(this.mapping);\n\n    if (!_.isEmpty(versions)) {\n      // Handle only selected versions if requested\n      log.debug(`Selecting chromedrivers whose versions match to ${versions}`);\n      driversToSync = driversToSync\n        .filter((cdName) => versions.includes(`${this.mapping[cdName].version}`));\n\n      log.debug(`Got ${util.pluralize('item', driversToSync.length, true)}`);\n      if (_.isEmpty(driversToSync)) {\n        return [];\n      }\n    }\n\n    if (!isNaN(minBrowserVersion)) {\n      // Only select drivers that support the current browser whose major version number equals to `minBrowserVersion`\n      const minBrowserVersionInt = parseInt(minBrowserVersion, 10);\n      log.debug(`Selecting chromedrivers whose minimum supported browser version matches to ${minBrowserVersionInt}`);\n      let closestMatchedVersionNumber = 0;\n      // Select the newest available and compatible chromedriver\n      for (const cdName of driversToSync) {\n        const currentMinBrowserVersion = parseInt(this.mapping[cdName].minBrowserVersion, 10);\n        if (!isNaN(currentMinBrowserVersion)\n            && currentMinBrowserVersion <= minBrowserVersionInt\n            && closestMatchedVersionNumber < currentMinBrowserVersion) {\n          closestMatchedVersionNumber = currentMinBrowserVersion;\n        }\n      }\n      driversToSync = driversToSync.filter((cdName) => `${this.mapping[cdName].minBrowserVersion}` ===\n        `${closestMatchedVersionNumber > 0 ? closestMatchedVersionNumber : minBrowserVersionInt}`);\n\n      log.debug(`Got ${util.pluralize('item', driversToSync.length, true)}`);\n      if (_.isEmpty(driversToSync)) {\n        return [];\n      }\n      log.debug(`Will select candidate ${util.pluralize('driver', driversToSync.length)} ` +\n        `versioned as '${_.uniq(driversToSync.map((cdName) => this.mapping[cdName].version))}'`);\n    }\n\n    if (!_.isEmpty(osInfo)) {\n      // Filter out drivers for unsupported system architectures\n      let {name, arch, hardwareName} = osInfo;\n      if (arch === X64 && !driversToSync.some((cdName) => cdName.includes(`_${name}${X64}`))) {\n        // Fall back to x86 build if x64 one is not available for the given OS\n        arch = X86;\n      }\n      if (name === OS.mac && _.includes(hardwareName, 'arm')\n          && driversToSync.some((cdName) => cdName.includes(M1_ARCH_SUFFIX))) {\n        // prefer executable for M1 arch if present\n        arch += M1_ARCH_SUFFIX;\n      }\n      log.debug(`Selecting chromedrivers whose platform matches to ${name}${arch}`);\n      const platformRe = new RegExp(`(\\\\b|_)${name}${arch}\\\\b`);\n      driversToSync = driversToSync.filter((cdName) => platformRe.test(cdName));\n      log.debug(`Got ${util.pluralize('item', driversToSync.length, true)}`);\n    }\n\n    return driversToSync;\n  }\n\n  /**\n   * Retrieves the given chromedriver from the storage\n   * and unpacks it into `this.chromedriverDir` folder\n   *\n   * @param {number} index - The unique driver index\n   * @param {string} driverKey - The driver key in `this.mapping`\n   * @param {string} archivesRoot - The temporary folder path to extract\n   * downloaded archives to\n   * @param {boolean} isStrict [true] - Whether to throw an error (`true`)\n   * or return a boolean result if the driver retrieval process fails\n   * @throws {Error} if there was a failure while retrieving the driver\n   * and `isStrict` is set to `true`\n   * @returns {boolean} if `true` then the chromedriver is successfully\n   * downloaded and extracted.\n   */\n  async retrieveDriver (index, driverKey, archivesRoot, isStrict = false) {\n    const { url, etag, version } = this.mapping[driverKey];\n    const archivePath = path.resolve(archivesRoot, `${index}.zip`);\n    log.debug(`Retrieving '${url}' to '${archivePath}'`);\n    try {\n      await net.downloadFile(url, archivePath, {\n        isMetered: false,\n        timeout: TIMEOUT_MS\n      });\n    } catch (e) {\n      const msg = `Cannot download chromedriver archive. Original error: ${e.message}`;\n      if (isStrict) {\n        throw new Error(msg);\n      }\n      log.error(msg);\n      return false;\n    }\n    if (!await isCrcOk(archivePath, etag)) {\n      const msg = `The checksum for the downloaded chromedriver '${driverKey}' did not match`;\n      if (isStrict) {\n        throw new Error(msg);\n      }\n      log.error(msg);\n      return false;\n    }\n    const fileName = `${path.parse(url).name}_v${version}` +\n      (system.isWindows() ? '.exe' : '');\n    const targetPath = path.resolve(this.chromedriverDir, fileName);\n    try {\n      await this.unzipDriver(archivePath, targetPath);\n      await fs.chmod(targetPath, 0o755);\n      log.debug(`Permissions of the file '${targetPath}' have been changed to 755`);\n    } catch (e) {\n      if (isStrict) {\n        throw e;\n      }\n      log.error(e.message);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * @typedef {Object} SyncOptions\n   * @property {Array<String>} versions - The list of chromedriver\n   * versions to sync. If empty (the default value) then all available\n   * chromedrivers are going to be downloaded and extracted\n   * @property {string|number} minBrowserVersion - The minumum supported\n   * Chrome version that downloaded chromedrivers should support. Can match\n   * multiple drivers.\n   * @property {?OSInfo} osInfo - System information used to filter out\n   * the list of the retrieved drivers. If not provided then the script\n   * will try to retrieve it.\n   */\n\n  /**\n   * Retrieves chromedrivers from the remote storage\n   * to the local file system\n   *\n   * @param {?SyncOptions} opts\n   * @throws {Error} if there was a problem while retrieving\n   * the drivers\n   * @returns {Array<String} The list of successfully synchronized driver keys\n   */\n  async syncDrivers (opts = {}) {\n    if (_.isEmpty(this.mapping)) {\n      await this.retrieveMapping(!!opts.minBrowserVersion);\n    }\n    if (_.isEmpty(this.mapping)) {\n      throw new Error('Cannot retrieve chromedrivers mapping from Google storage');\n    }\n\n    const driversToSync = this.selectMatchingDrivers(opts.osInfo ?? await getOsInfo(), opts);\n    if (_.isEmpty(driversToSync)) {\n      log.debug(`There are no drivers to sync. Exiting`);\n      return [];\n    }\n    log.debug(`Got ${util.pluralize('driver', driversToSync.length, true)} to sync: ` +\n      JSON.stringify(driversToSync, null, 2));\n\n    const synchronizedDrivers = [];\n    const promises = [];\n    const archivesRoot = await tempDir.openDir();\n    try {\n      for (const [idx, driverKey] of driversToSync.entries()) {\n        promises.push((async () => {\n          if (await this.retrieveDriver(idx, driverKey, archivesRoot, !_.isEmpty(opts))) {\n            synchronizedDrivers.push(driverKey);\n          }\n        })());\n\n        if (promises.length % MAX_PARALLEL_DOWNLOADS === 0) {\n          await B.all(promises);\n        }\n      }\n      await B.all(promises);\n    } finally {\n      await fs.rimraf(archivesRoot);\n    }\n    if (!_.isEmpty(synchronizedDrivers)) {\n      log.info(`Successfully synchronized ` +\n        `${util.pluralize('chromedriver', synchronizedDrivers.length, true)}`);\n    } else {\n      log.info(`No chromedrivers were synchronized`);\n    }\n    return synchronizedDrivers;\n  }\n}\n\n\nexport default ChromedriverStorageClient;\n"],"mappings":"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"}