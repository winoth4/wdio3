"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
require("source-map-support/register");
var _logger = _interopRequireDefault(require("../logger.js"));
var _asyncbox = require("asyncbox");
const KEYCODE_ESC = 111;
const KEYCODE_BACK = 4;
const keyboardCommands = {};
keyboardCommands.hideKeyboard = async function hideKeyboard(timeoutMs = 1000) {
  let {
    isKeyboardShown,
    canCloseKeyboard
  } = await this.isSoftKeyboardPresent();
  if (!isKeyboardShown) {
    _logger.default.info('Keyboard has no UI; no closing necessary');
    return false;
  }
  for (const keyCode of [KEYCODE_ESC, KEYCODE_BACK]) {
    if (canCloseKeyboard) {
      await this.keyevent(keyCode);
    }
    try {
      return await (0, _asyncbox.waitForCondition)(async () => {
        ({
          isKeyboardShown
        } = await this.isSoftKeyboardPresent());
        return !isKeyboardShown;
      }, {
        waitMs: timeoutMs,
        intervalMs: 500
      });
    } catch (ign) {}
  }
  throw new Error(`The software keyboard cannot be hidden`);
};
keyboardCommands.isSoftKeyboardPresent = async function isSoftKeyboardPresent() {
  try {
    const stdout = await this.shell(['dumpsys', 'input_method']);
    const inputShownMatch = /mInputShown=(\w+)/.exec(stdout);
    const inputViewShownMatch = /mIsInputViewShown=(\w+)/.exec(stdout);
    return {
      isKeyboardShown: !!(inputShownMatch && inputShownMatch[1] === 'true'),
      canCloseKeyboard: !!(inputViewShownMatch && inputViewShownMatch[1] === 'true')
    };
  } catch (e) {
    throw new Error(`Error finding softkeyboard. Original error: ${e.message}`);
  }
};
var _default = keyboardCommands;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJLRVlDT0RFX0VTQyIsIktFWUNPREVfQkFDSyIsImtleWJvYXJkQ29tbWFuZHMiLCJoaWRlS2V5Ym9hcmQiLCJ0aW1lb3V0TXMiLCJpc0tleWJvYXJkU2hvd24iLCJjYW5DbG9zZUtleWJvYXJkIiwiaXNTb2Z0S2V5Ym9hcmRQcmVzZW50IiwibG9nIiwiaW5mbyIsImtleUNvZGUiLCJrZXlldmVudCIsIndhaXRGb3JDb25kaXRpb24iLCJ3YWl0TXMiLCJpbnRlcnZhbE1zIiwiaWduIiwiRXJyb3IiLCJzdGRvdXQiLCJzaGVsbCIsImlucHV0U2hvd25NYXRjaCIsImV4ZWMiLCJpbnB1dFZpZXdTaG93bk1hdGNoIiwiZSIsIm1lc3NhZ2UiXSwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvdG9vbHMva2V5Ym9hcmQtY29tbWFuZHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXIuanMnO1xuaW1wb3J0IHsgd2FpdEZvckNvbmRpdGlvbiB9IGZyb20gJ2FzeW5jYm94JztcblxuY29uc3QgS0VZQ09ERV9FU0MgPSAxMTE7XG5jb25zdCBLRVlDT0RFX0JBQ0sgPSA0O1xuXG5jb25zdCBrZXlib2FyZENvbW1hbmRzID0ge307XG5cbi8qKlxuICogSGlkZXMgc29mdHdhcmUga2V5Ym9hcmQgaWYgaXQgaXMgdmlzaWJsZS5cbiAqIE5vb3AgaWYgdGhlIGtleWJvYXJkIGlzIGFscmVhZHkgaGlkZGVuLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TXMgWzEwMDBdIEZvciBob3cgbG9uZyB0byB3YWl0IChpbiBtaWxsaXNlY29uZHMpXG4gKiB1bnRpbCB0aGUga2V5Ym9hcmQgaXMgYWN0dWFsbHkgaGlkZGVuLlxuICogQHJldHVybnMge2Jvb2xlYW59IGBmYWxzZWAgaWYgdGhlIGtleWJvYXJkIHdhcyBhbHJlYWR5IGhpZGRlblxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBrZXlib2FyZCBjYW5ub3QgYmUgaGlkZGVuLlxuICovXG5rZXlib2FyZENvbW1hbmRzLmhpZGVLZXlib2FyZCA9IGFzeW5jIGZ1bmN0aW9uIGhpZGVLZXlib2FyZCAodGltZW91dE1zID0gMTAwMCkge1xuICBsZXQge2lzS2V5Ym9hcmRTaG93biwgY2FuQ2xvc2VLZXlib2FyZH0gPSBhd2FpdCB0aGlzLmlzU29mdEtleWJvYXJkUHJlc2VudCgpO1xuICBpZiAoIWlzS2V5Ym9hcmRTaG93bikge1xuICAgIGxvZy5pbmZvKCdLZXlib2FyZCBoYXMgbm8gVUk7IG5vIGNsb3NpbmcgbmVjZXNzYXJ5Jyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRyeSBFU0MgdGhlbiBCQUNLIGlmIHRoZSBmaXJzdCBvbmUgZmFpbHNcbiAgZm9yIChjb25zdCBrZXlDb2RlIG9mIFtLRVlDT0RFX0VTQywgS0VZQ09ERV9CQUNLXSkge1xuICAgIGlmIChjYW5DbG9zZUtleWJvYXJkKSB7XG4gICAgICBhd2FpdCB0aGlzLmtleWV2ZW50KGtleUNvZGUpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICAoe2lzS2V5Ym9hcmRTaG93bn0gPSBhd2FpdCB0aGlzLmlzU29mdEtleWJvYXJkUHJlc2VudCgpKTtcbiAgICAgICAgcmV0dXJuICFpc0tleWJvYXJkU2hvd247XG4gICAgICB9LCB7d2FpdE1zOiB0aW1lb3V0TXMsIGludGVydmFsTXM6IDUwMH0pO1xuICAgIH0gY2F0Y2ggKGlnbikge31cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzb2Z0d2FyZSBrZXlib2FyZCBjYW5ub3QgYmUgaGlkZGVuYCk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEtleWJvYXJkU3RhdGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNLZXlib2FyZFNob3duIC0gV2hldGhlciBzb2Z0IGtleWJvYXJkIGlzIGN1cnJlbnRseSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBjYW5DbG9zZUtleWJvYXJkIC0gV2hldGhlciB0aGUga2V5Ym9hcmQgY2FuIGJlIGNsb3NlZC5cbiAqL1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBzdGF0ZSBvZiB0aGUgc29mdHdhcmUga2V5Ym9hcmQgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge0tleWJvYXJkU3RhdGV9IFRoZSBrZXlib2FyZCBzdGF0ZS5cbiAqL1xua2V5Ym9hcmRDb21tYW5kcy5pc1NvZnRLZXlib2FyZFByZXNlbnQgPSBhc3luYyBmdW5jdGlvbiBpc1NvZnRLZXlib2FyZFByZXNlbnQgKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoWydkdW1wc3lzJywgJ2lucHV0X21ldGhvZCddKTtcbiAgICBjb25zdCBpbnB1dFNob3duTWF0Y2ggPSAvbUlucHV0U2hvd249KFxcdyspLy5leGVjKHN0ZG91dCk7XG4gICAgY29uc3QgaW5wdXRWaWV3U2hvd25NYXRjaCA9IC9tSXNJbnB1dFZpZXdTaG93bj0oXFx3KykvLmV4ZWMoc3Rkb3V0KTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNLZXlib2FyZFNob3duOiAhIShpbnB1dFNob3duTWF0Y2ggJiYgaW5wdXRTaG93bk1hdGNoWzFdID09PSAndHJ1ZScpLFxuICAgICAgY2FuQ2xvc2VLZXlib2FyZDogISEoaW5wdXRWaWV3U2hvd25NYXRjaCAmJiBpbnB1dFZpZXdTaG93bk1hdGNoWzFdID09PSAndHJ1ZScpLFxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGZpbmRpbmcgc29mdGtleWJvYXJkLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGtleWJvYXJkQ29tbWFuZHM7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUVBLE1BQU1BLFdBQVcsR0FBRyxHQUFHO0FBQ3ZCLE1BQU1DLFlBQVksR0FBRyxDQUFDO0FBRXRCLE1BQU1DLGdCQUFnQixHQUFHLENBQUMsQ0FBQztBQVczQkEsZ0JBQWdCLENBQUNDLFlBQVksR0FBRyxlQUFlQSxZQUFZLENBQUVDLFNBQVMsR0FBRyxJQUFJLEVBQUU7RUFDN0UsSUFBSTtJQUFDQyxlQUFlO0lBQUVDO0VBQWdCLENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQ0MscUJBQXFCLEVBQUU7RUFDNUUsSUFBSSxDQUFDRixlQUFlLEVBQUU7SUFDcEJHLGVBQUcsQ0FBQ0MsSUFBSSxDQUFDLDBDQUEwQyxDQUFDO0lBQ3BELE9BQU8sS0FBSztFQUNkO0VBRUEsS0FBSyxNQUFNQyxPQUFPLElBQUksQ0FBQ1YsV0FBVyxFQUFFQyxZQUFZLENBQUMsRUFBRTtJQUNqRCxJQUFJSyxnQkFBZ0IsRUFBRTtNQUNwQixNQUFNLElBQUksQ0FBQ0ssUUFBUSxDQUFDRCxPQUFPLENBQUM7SUFDOUI7SUFDQSxJQUFJO01BQ0YsT0FBTyxNQUFNLElBQUFFLDBCQUFnQixFQUFDLFlBQVk7UUFDeEMsQ0FBQztVQUFDUDtRQUFlLENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQ0UscUJBQXFCLEVBQUU7UUFDdkQsT0FBTyxDQUFDRixlQUFlO01BQ3pCLENBQUMsRUFBRTtRQUFDUSxNQUFNLEVBQUVULFNBQVM7UUFBRVUsVUFBVSxFQUFFO01BQUcsQ0FBQyxDQUFDO0lBQzFDLENBQUMsQ0FBQyxPQUFPQyxHQUFHLEVBQUUsQ0FBQztFQUNqQjtFQUNBLE1BQU0sSUFBSUMsS0FBSyxDQUFFLHdDQUF1QyxDQUFDO0FBQzNELENBQUM7QUFhRGQsZ0JBQWdCLENBQUNLLHFCQUFxQixHQUFHLGVBQWVBLHFCQUFxQixHQUFJO0VBQy9FLElBQUk7SUFDRixNQUFNVSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUNDLEtBQUssQ0FBQyxDQUFDLFNBQVMsRUFBRSxjQUFjLENBQUMsQ0FBQztJQUM1RCxNQUFNQyxlQUFlLEdBQUcsbUJBQW1CLENBQUNDLElBQUksQ0FBQ0gsTUFBTSxDQUFDO0lBQ3hELE1BQU1JLG1CQUFtQixHQUFHLHlCQUF5QixDQUFDRCxJQUFJLENBQUNILE1BQU0sQ0FBQztJQUNsRSxPQUFPO01BQ0xaLGVBQWUsRUFBRSxDQUFDLEVBQUVjLGVBQWUsSUFBSUEsZUFBZSxDQUFDLENBQUMsQ0FBQyxLQUFLLE1BQU0sQ0FBQztNQUNyRWIsZ0JBQWdCLEVBQUUsQ0FBQyxFQUFFZSxtQkFBbUIsSUFBSUEsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLEtBQUssTUFBTTtJQUMvRSxDQUFDO0VBQ0gsQ0FBQyxDQUFDLE9BQU9DLENBQUMsRUFBRTtJQUNWLE1BQU0sSUFBSU4sS0FBSyxDQUFFLCtDQUE4Q00sQ0FBQyxDQUFDQyxPQUFRLEVBQUMsQ0FBQztFQUM3RTtBQUNGLENBQUM7QUFBQyxlQUVhckIsZ0JBQWdCO0FBQUEifQ==