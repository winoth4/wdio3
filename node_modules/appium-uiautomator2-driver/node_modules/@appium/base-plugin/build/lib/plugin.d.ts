export default BasePlugin;
export type Plugin = import('@appium/types').Plugin;
/**
 * @implements {Plugin}
 */
export class BasePlugin implements Plugin {
    /**
     * Subclasses should use type `import('@appium/types').MethodMap<SubclassName>`.
     *
     * This will verify that the commands in the `newMethodMap` property are
     * valid.  It is impossible to use a generic type param here; the type of this should really
     * be something like `MethodMap<T extends BasePlugin>` but that isn't a thing TS does.
     *
     * ```ts
     * static newMethodMap = {
     *   '/session/:sessionId/fake_data': {
     *     GET: {command: 'getFakeSessionData', neverProxy: true},
     *   }
     * } as const;
     * ```
     */
    static newMethodMap: {};
    /**
     * @param {string} name
     * @param {Record<string,unknown>} [cliArgs]
     */
    constructor(name: string, cliArgs?: Record<string, unknown> | undefined);
    name: string;
    cliArgs: Record<string, unknown>;
    logger: import("@appium/types").AppiumLogger;
}
//# sourceMappingURL=plugin.d.ts.map