"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecuteMixin = void 0;
const lodash_1 = __importDefault(require("lodash"));
const protocol_1 = require("../../protocol");
/**
 * @template {Constraints} C
 * @param {import('./session').SessionBase<C>} Base
 * @returns {ExecuteBase<C>}
 */
function ExecuteMixin(Base) {
    /**
     * @implements {IExecuteCommands}
     */
    class ExecuteCommands extends Base {
        /**
         * @param {string} script
         * @param {[Record<string, any>]|[]} protoArgs
         */
        async executeMethod(script, protoArgs) {
            var _a, _b;
            // the w3c protocol will give us an array of arguments to apply to a javascript function.
            // that's not what we're doing. we're going to look for a JS object as the first arg, so we
            // can perform validation on it. we'll ignore everything else.
            if (!protoArgs || !lodash_1.default.isArray(protoArgs) || protoArgs.length > 1) {
                throw new protocol_1.errors.InvalidArgumentError(`Did not get correct format of arguments for execute method. Expected zero or one ` +
                    `arguments to execute script and instead received: ${JSON.stringify(protoArgs)}`);
            }
            let args = protoArgs[0] ?? {};
            if (!lodash_1.default.isPlainObject(args)) {
                throw new protocol_1.errors.InvalidArgumentError(`Did not receive an appropriate execute method parameters object. It needs to be ` +
                    `deserializable as a plain JS object`);
            }
            const Driver = /** @type {DriverClass} */ (this.constructor);
            const commandMetadata = { ...Driver.executeMethodMap?.[script] };
            if (!commandMetadata.command) {
                const availableScripts = lodash_1.default.keys(Driver.executeMethodMap);
                throw new protocol_1.errors.UnsupportedOperationError(`Unsupported execute method '${script}'. Available methods ` +
                    `are: ${availableScripts.join(', ')}`);
            }
            let argsToApply = [];
            if (!commandMetadata.params) {
                commandMetadata.params = { required: [], optional: [] };
            }
            else {
                (_a = commandMetadata.params).required ?? (_a.required = []);
                (_b = commandMetadata.params).optional ?? (_b.optional = []);
                (0, protocol_1.checkParams)(commandMetadata.params, args, null);
            }
            argsToApply = (0, protocol_1.makeArgs)({}, args, commandMetadata.params, null);
            return await this[commandMetadata.command](...argsToApply);
        }
    }
    return ExecuteCommands;
}
exports.ExecuteMixin = ExecuteMixin;
/**
 * @typedef {import('@appium/types').IExecuteCommands} IExecuteCommands
 * @typedef {import('@appium/types').Driver} Driver
 * @typedef {import('@appium/types').DriverClass} DriverClass
 * @typedef {import('@appium/types').Constraints} Constraints
 */
/**
 * @template {Constraints} C
 * @typedef {import('../driver').BaseDriverBase<C, import('@appium/types').ITimeoutCommands & import('@appium/types').IEventCommands & import('@appium/types').IFindCommands & import('@appium/types').ILogCommands<C> & import('@appium/types').ISettingsCommands & import('@appium/types').ISessionCommands & IExecuteCommands>} ExecuteBase
 */
//# sourceMappingURL=execute.js.map