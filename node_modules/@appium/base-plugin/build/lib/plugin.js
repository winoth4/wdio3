"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasePlugin = void 0;
const support_1 = require("@appium/support");
/**
 * @implements {Plugin}
 */
class BasePlugin {
    /**
     * @param {string} name
     * @param {Record<string,unknown>} [cliArgs]
     */
    constructor(name, cliArgs = {}) {
        this.name = name;
        this.cliArgs = cliArgs;
        this.logger = support_1.logger.getLogger(`Plugin [${name}]`);
    }
}
exports.BasePlugin = BasePlugin;
/**
 * Subclasses should use type `import('@appium/types').MethodMap<SubclassName>`.
 *
 * This will verify that the commands in the `newMethodMap` property are
 * valid.  It is impossible to use a generic type param here; the type of this should really
 * be something like `MethodMap<T extends BasePlugin>` but that isn't a thing TS does.
 *
 * ```ts
 * static newMethodMap = {
 *   '/session/:sessionId/fake_data': {
 *     GET: {command: 'getFakeSessionData', neverProxy: true},
 *   }
 * } as const;
 * ```
 */
BasePlugin.newMethodMap = {};
exports.default = BasePlugin;
/**
 * @typedef {import('@appium/types').Plugin} Plugin
 */
//# sourceMappingURL=plugin.js.map